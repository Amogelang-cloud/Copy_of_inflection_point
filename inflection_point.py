# -*- coding: utf-8 -*-
"""Inflection Point.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zG88KDbyvwG-EA5rIm4Yo642ydOTKxYO
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# Load the data
df = pd.read_csv("/content/drive/MyDrive/south_africa_population_1974_2023.csv")

# Convert 'Year' to a datetime format and extract just the year and population
df['Year'] = pd.to_datetime(df['Year'], format='%Y').dt.year
df_extracted = df[['Year', 'Population']]

# Calculate the first derivative (rate of change of population)
first_derivative = np.gradient(df_extracted['Population'], df_extracted['Year'])

# Calculate the second derivative (rate of change of the first derivative)
second_derivative = np.gradient(first_derivative, df_extracted['Year'])

# Find inflection points (where second derivative changes sign)
inflection_points = np.where(np.diff(np.sign(second_derivative)))[0]

# Plot the original data and mark the inflection points
plt.figure(figsize=(6,4))
plt.plot(df_extracted['Year'], df_extracted['Population'], '.', label='Population data', color='orange')
plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)
plt.title('South Africa Population with Inflection Points')
plt.xlabel('Year')
plt.ylabel('Total Population')
plt.grid(True)
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

# Output the inflection points
inflection_years = df_extracted['Year'].iloc[inflection_points]
inflection_populations = df_extracted['Population'].iloc[inflection_points]


for year, pop in zip(inflection_years, inflection_populations):
    print(f"Inflection point: Year {year}, Population {pop}")

def bi_logistic(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Parameters for the model
K1 = 46813266  # Given value for K1
K2 = 57339635-K1   # Given value for K2
alpha_k = 0.5
tm =  2000 # tm is the year when the midpoint is expected

# Time range: from 1974 to 2023
t = np.linspace(1974, 2023, 400)

# Calculate K(t)
K_t = bi_logistic(t, K1, K2, alpha_k, tm)


# Plotting both the bi-logistic model and the population data
plt.figure(figsize=(6, 4))

# Plot the bi-logistic model
plt.plot(t, K_t, label='Bi-logistic model', color='b')

# Marking K1, K2, and K1 + K2
plt.scatter(1980, K1,color='black', label=f'K1 = {K1}')
plt.scatter(2010, K1 + K2, color='black', label=f'K1 + K2 = {K1 + K2}')

plt.title('Bi-Logistic Model with Carrying Capacity K1, K2 and K1+K2')
plt.xlabel('Year')
plt.ylabel('K(t)')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

def bi_logistic(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Parameters for the model
K1 = 46813266
K2 = 57339635-K1
alpha_k = 0.5
tm =  2000

# Time range: from 1974 to 2023
t = np.linspace(1974, 2023, 400)

# Calculate K(t)
K_t = bi_logistic(t, K1, K2, alpha_k, tm)


# Plotting both the bi-logistic model and the population data
plt.figure(figsize=(6, 4))


plt.plot(t, K_t, label='Bi-logistic model', color='b')
plt.scatter(1980, K1,color='black', label=f'K1 = {K1}')
plt.scatter(2010, K1 + K2, color='black', label=f'K2 = {K1+K2}')

# Plot the original population data withthe points of inflection
plt.plot(df_extracted['Year'], df_extracted['Population'], '.', label='Population data', color='orange')
plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)


# Plot details
plt.title('Bi-logistic Model and South Africa Population')
plt.xlabel('Year')
plt.ylabel('Total Population / K(t)')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

from scipy.integrate import odeint

# Define time-varying carrying capacity K(t)
def K(t):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Define Logistic growth model
def logistic_growth(P, t, alpha, alpha_k):
    K1 = 46813266
    K2 = 57339655- K1
    tm = 2000
    return alpha* P * (1 - P / (K(t)))

# Time range from 1974 to 2023
t = np.linspace(1974, 2023, 400)

# Initial population (in 1974)
P0 = 25077016

# Parameters
alpha = 0.450
alpha_k= 0.500

# Solve ODE
P = odeint(logistic_growth, P0, t, args=(alpha, alpha_k))

# Plotting the bi-logistic model and the population data
plt.figure(figsize=(6, 4))

plt.plot(df_extracted['Year'], df_extracted['Population'], '.', label='Population data', color='orange')
plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)

plt.plot(t, P, label="Logistic Growth Model P(t)", color="red")
plt.title("Logistic Growth with Time-Varying Carrying Capacity (SA Population)")
plt.xlabel("Year")
plt.ylabel("Population")
plt.grid(True)
plt.legend()
plt.show()

plt.figure(figsize=(6, 4))


# Plot the bi-logistic model
plt.plot(t, K_t, label='Bi-logistic model', color='b')
plt.scatter(1980, K1,color='black', label=f'K1 = {K1}')
plt.scatter(2010, K1 + K2, color='black', label=f'K2 = {K1 + K2}')

plt.plot(df_extracted['Year'], df_extracted['Population'], '.', label='Population data', color='orange')
plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)

plt.plot(t, P, label="Logistic Growth Model P(t)", color="red")
plt.title("Logistic Growth with Time-Varying Carrying Capacity (SA Population)")
plt.xlabel("Year")
plt.ylabel("Population")
plt.grid(True)
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.optimize import curve_fit

# Define time-varying carrying capacity K(t)
def K(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Logistic growth model
def logistic_growth(P, t, alpha, alpha_k, K1, K2, tm):
    return alpha * P * (1 - P / K(t, K1, K2, alpha_k, tm))

# Wrapper function for curve fitting, includes P0, K1, K2, and tm
def fit_logistic_growth(t, alpha, alpha_k, K1, K2, tm):
    # Solve the ODE with the given parameters
    P = odeint(logistic_growth, P0, t, args=(alpha, alpha_k, K1, K2, tm))
    return P.ravel()  # Flatten the array for curve fitting

def bi_logistic(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))


t = np.linspace(1974, 2023, 400)

# Initial guess for parameters [P0, alpha, alpha_k, K1, K2, tm]
initial_guess = [ 0.45, 0.50, 46813266, 10500000, 2000]

# Extract the data from the dataframe
years = df_extracted['Year']
population_data = df_extracted['Population']

# Use curve_fit to find optimal parameters (P0, alpha, alpha_k, K1, K2, tm)
popt, pcov = curve_fit(fit_logistic_growth, years, population_data, p0=initial_guess)

# Extract fitted parameters
alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted = popt

# Solve the ODE using the fitted parameters
P_fitted = fit_logistic_growth(t, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted)

# Calculate the bi-logistic curve
K1_bi = 46813266
K2_bi = 57339635 - K1_bi
alpha_k_bi = 0.500
tm_bi = 2000

# Calculate K(t) for the bi-logistic model
K_t_bi = bi_logistic(t, K1_bi, K2_bi, alpha_k_bi, tm_bi)

# Plotting both the bi-logistic model and the fitted logistic growth curve
plt.figure(figsize=(6, 4))

plt.plot(t, K_t_bi, label='Bi-logistic model K(t)', color='b', linestyle='--')


plt.scatter(1980, K1_bi, color='black', label=f'K1 = {K1_bi}')
plt.scatter(2010, K1_bi + K2_bi, color='black', label=f'K2 = {K1_bi + K2_bi}')

# Plot the fitted logistic growth model
plt.plot(t, P_fitted, label="Fitted Logistic Growth Model P(t)", color="red")

# Plot the population data
plt.plot(years, population_data, '.', label='Population data', color='orange')

# Mark inflection points
plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)

plt.title("Logistic Growth and Bi-logistic Model for SA Population")
plt.xlabel("Year")
plt.ylabel("Population")
plt.grid(True)
plt.legend()

# Show the plot
plt.show()

#Print the optimized parameters

print(f"Fitted alpha: {alpha_fitted}")
print(f"Fitted alpha_k: {alpha_k_fitted}")
print(f"Fitted K1: {K1_fitted}")
print(f"Fitted K2: {K2_fitted}")
print(f"Fitted tm: {tm_fitted}")

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.optimize import curve_fit

# Define time-varying carrying capacity K(t)
def K(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Logistic growth model
def logistic_growth(P, t, alpha, alpha_k, K1, K2, tm):
    return alpha * P * (1 - P / K(t, K1, K2, alpha_k, tm))

# Wrapper function for curve fitting, includes P0, K1, K2, and tm
def fit_logistic_growth(t, P0, alpha, alpha_k, K1, K2, tm):
    # Solve the ODE with the given parameters
    P = odeint(logistic_growth, P0, t, args=(alpha, alpha_k, K1, K2, tm))
    return P.ravel()  # Flatten the array for curve fitting

# Bi-logistic model function
def bi_logistic(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Time range from 1974 to 2023
t = np.linspace(1974, 2023, 400)

# Initial guess for parameters [P0, alpha, alpha_k, K1, K2, tm]
initial_guess = [25077016, 0.105, 0.500, 46813266, 10500000, 2000]

# Extract the data from the dataframe
years = df_extracted['Year']
population_data = df_extracted['Population']

# Use curve_fit to find optimal parameters (P0, alpha, alpha_k, K1, K2, tm)
popt, pcov = curve_fit(fit_logistic_growth, years, population_data, p0=initial_guess)

# Extract fitted parameters
P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted = popt

# Solve the ODE using the fitted parameters
P_fitted = fit_logistic_growth(t, P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted)

# Calculate the bi-logistic curve using the fitted values
K_t_bi_fitted = bi_logistic(t, K1_fitted, K2_fitted, alpha_k_fitted, tm_fitted)

# Plotting both the fitted bi-logistic model and the fitted logistic growth curve
plt.figure(figsize=(6, 4))

# Plot the bi-logistic model with fitted values
plt.plot(t, K_t_bi_fitted, label='Fitted Bi-logistic model K(t)', color='b', linestyle='--')

# Plot the fitted logistic growth model
plt.plot(t, P_fitted, label="Fitted Logistic Growth Model P(t)", color="red")

# Plot the population data
plt.plot(years, population_data, '.', label='Population data', color='orange')

plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)

# Add labels and title
plt.title("Fitted Logistic Growth and Bi-logistic Model for SA Population")
plt.xlabel("Year")
plt.ylabel("Population")
plt.grid(True)
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.optimize import curve_fit

# Define time-varying carrying capacity K(t)
def K(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Logistic growth model
def logistic_growth(P, t, alpha, alpha_k, K1, K2, tm):
    return alpha * P * (1 - P / K(t, K1, K2, alpha_k, tm))

# Wrapper function for curve fitting, includes P0, K1, K2, and tm
def fit_logistic_growth(t, P0, alpha, alpha_k, K1, K2, tm):
    # Solve the ODE with the given parameters
    P = odeint(logistic_growth, P0, t, args=(alpha, alpha_k, K1, K2, tm))
    return P.ravel()  # Flatten the array for curve fitting

# Bi-logistic model function (used for carrying capacity)
def bi_logistic(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Time range from 1974 to 2023 for fitting, extend to future for prediction
t = np.linspace(1974, 2050, 500)  # Extend time range to 2050 for predictions

# Initial guess for parameters [P0, alpha, alpha_k, K1, K2, tm]
initial_guess = [25077016, 0.105, 0.500, 46813266, 10500000, 2000]

# Extract the data from the dataframe
years = df_extracted['Year'].values
population_data = df_extracted['Population'].values

# Use curve_fit to find optimal parameters (P0, alpha, alpha_k, K1, K2, tm)
popt, pcov = curve_fit(fit_logistic_growth, years, population_data, p0=initial_guess)

# Extract fitted parameters
P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted = popt

# Solve the ODE using the fitted parameters to predict future population
P_fitted = fit_logistic_growth(t, P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted)

# Calculate the bi-logistic curve using the fitted values
K_t_bi_fitted = bi_logistic(t, K1_fitted, K2_fitted, alpha_k_fitted, tm_fitted)

# Plotting both the fitted bi-logistic model and the fitted logistic growth curve
plt.figure(figsize=(6, 4))

# Plot the bi-logistic model with fitted values
plt.plot(t, K_t_bi_fitted, label='Fitted Bi-logistic model K(t)', color='blue', linestyle='--')
plt.scatter(df_extracted['Year'].iloc[inflection_points], df_extracted['Population'].iloc[inflection_points],
            color='red', label='Inflection points', zorder=2)

# Plot the fitted logistic growth model
plt.plot(t, P_fitted, label="Fitted Logistic Growth Model P(t)", color="black")

# Plot the population data
plt.plot(years, population_data, '.', label='Population data', color='orange')

plt.title("Fitted Logistic Growth and Bi-logistic Model for SA Population (with Future Predictions)")
plt.xlabel("Year")
plt.ylabel("Population")
plt.grid(True)
plt.legend()
plt.show()

# Print the optimized parameters
print(f"Fitted P0: {int(P0_fitted)}")
print(f"Fitted alpha: {float(alpha_fitted)}")
print(f"Fitted alpha_k: {float(alpha_k_fitted)}")
print(f"Fitted K1: {int(K1_fitted)}")
print(f"Fitted K2: {int(K2_fitted)}")
print(f"Fiited K2 + Fitted K1: {int(K1_fitted + K2_fitted)}")
print(f"Fitted tm: {int(tm_fitted)}")

# Predict population
years_to_predict = [1996,2001, 2011, 2022, 2032]
P_predictions = np.interp(years_to_predict, t, P_fitted)

# Print the predictions
for year, pop in zip(years_to_predict, P_predictions):
    print(f"Predicted population in {year}: {int(pop)}")

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.optimize import curve_fit
from sklearn.metrics import mean_squared_error

# Define time-varying carrying capacity K(t)
def K(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Logistic growth model
def logistic_growth(P, t, alpha, alpha_k, K1, K2, tm):
    return alpha * P * (1 - P / K(t, K1, K2, alpha_k, tm))

# Wrapper function for curve fitting, includes P0, K1, K2, and tm
def fit_logistic_growth(t, P0, alpha, alpha_k, K1, K2, tm):
    # Solve the ODE with the given parameters
    P = odeint(logistic_growth, P0, t, args=(alpha, alpha_k, K1, K2, tm))
    return P.ravel()

# Bi-logistic model function
def bi_logistic(t, K1, K2, alpha_k, tm):
    return K1 + K2 / (1 + np.exp(-alpha_k * (t - tm)))

# Time range from 1974 to 2023 for fitting, extend to future for prediction
t = np.linspace(1974, 2050 , 500)

# Initial guess for parameters [P0, alpha, alpha_k, K1, K2, tm]
initial_guess = [25077016, 0.105, 0.500, 46813266, 10500000, 2000]

# Extract the data from the dataframe
years = df_extracted['Year'].values
population_data = df_extracted['Population'].values

# Use curve_fit to find optimal parameters (P0, alpha, alpha_k, K1, K2, tm)
popt, pcov = curve_fit(fit_logistic_growth, years , population_data, p0=initial_guess)

# Extract fitted parameters
P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted = popt

# Solve the ODE using the fitted parameters to predict future population
P_fitted = fit_logistic_growth(t, P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted)

# Solve for the years corresponding to the actual data
P_fitted_actual_years = fit_logistic_growth(years , P0_fitted, alpha_fitted, alpha_k_fitted, K1_fitted, K2_fitted, tm_fitted)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(population_data, P_fitted_actual_years))
mean_population = np.mean(population_data)
percentage_error = (rmse / mean_population) * 100
print(f"RMSE: {rmse}")
print(f"Mean: {mean_population}")
print(f"Percentage Error: {percentage_error}%")